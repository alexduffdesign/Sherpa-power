</rules>

<rule>
Rule 1 - When writing code, ALWAYS follow the Architecture and Separation of Concerns:

## Core Logic (baseChatbot/base-chatbot.js)

Web Component: Utilized as a base class for both Main and Section Chatbots.

Responsible for handling the conversation flow, sending requests to the Voiceflow API via the Gadget middleware, and processing the SSE (Server-Sent Events) responses.
No direct DOM manipulation or UI rendering code. Only data handling, event emissions, and state management belong here.

## Core UI (baseChatbot/base-chatbot-ui.js)

Responsible for rendering messages, interactive elements (buttons, carousels), and updating the frontend as instructed by events from the core.

## Main Chatbot (mainChatbot/chatbot-main.js)

Extends BaseChatbot with specific logic for the Main Chatbot.
Responsible for managing the Main Chatbot's conversation history, UI updates, and user input handling.
No direct API calls.

## Main Chatbot UI (mainChatbot/chatbot-main-ui.js)

Responsible for rendering specific UI elements for the Main Chatbot.

## Section Chatbot (sectionChatbot/chatbot-section.js)

Extends BaseChatbot with specific logic for the Section Chatbot. (deviece_answer)

## Section Chatbot UI (sectionChatbot/chatbot-section-ui.js)

Responsible for rendering specific UI elements for the Section Chatbot. (deviece_answer)

## UI Components (message-component, button-component, carousel-component)

Self-contained UI elements.
No network requests or complex logic, just represent and display data passed to them.

# Utils (event-bus, event-constants, user-id-generator)

Shared logic or services used across Core and UI layers, such as event handling and ID generation.
No domain-specific business logic or UI rendering should occur here.
Voiceflow and Gadget Integration

# chatbot-template.liquid is the html file that both chatbots use.

# chatbot-drawer.liquid is where the main chatbots is rendered.

# application.liquid is where the section chatbot is rendered.

</rule>

<rule>

# Differentiate between the main chatbot features and the section chatbot features.

Main Features Common to Both Chatbots:

Differences between Main and Section Chatbots:

## Main Chatbot Specific Features:

Conversation History:

Stores chat history in localStorage
Can load and restore previous conversations
Maintains interactive element state
Stores user ID persistently

Global Navigation:

Has a main menu functionality (sends 'main-menu' event payload)
Maintains conversation state across sessions

Launch Behavior:

Tracks launch state in localStorage
Only launches once per session
Can restore previous state on reload

## Section Chatbot Specific Features:

Product Context:

Handles product-specific details
Maintains product context in conversations
Validates product information
Product-specific launch payload

Handles device_answer traces:
Outputs device answers into the applications-grid

Focused Interactions:

No conversation history
Stateless between sessions
Focused on immediate product context
Launches on first input focus

Specialized UI:

Product-specific UI elements for displaying device_answer traces

Launch Behavior:

Launches on input focus
Includes product details in launch payload
Validates product details before launch
No persistent launch state

</rule>

<rule>

# chatbot-drawer.liquid

You will see in this file that we have a custom web component called custom-drawer.

When we open the drawer for the first time, it will launch the main chatbot and save a flag to indicate that the drawer has been opened.

This is to prevent the main chatbot from launching multiple times when the drawer is opened again.

We need the main chatbot to launch when the drawer is first opened.

</rule>

<rule>
Rule 2 - Remember the tech stack used:Voiceflow and Gadget Integration:
Voiceflow API

All communication with Voiceflow occurs through the Gadget API endpoint.
Voiceflow Project ID and API Key are configured via environment variables.
No direct Voiceflow calls in UI files—only from ChatbotCore or Gadget routes.
Gadget Middleware

Acts as a proxy to Voiceflow’s SSE endpoint.
Handles authentication, streaming events, and error handling before passing data back to the frontend.
Documentation and Style

We are using eventemitter3 for event handling.
We are using vite for bundling.
</rule>

<rule>
Rule 3 - For each function or class, write a JSDoc Comments:

Every function and class should include a JSDoc header block describing parameters, return values, and purpose.
Maintain consistent JSDoc format throughout the codebase.
Code Consistency
</rule>

<rule>

# Give confidence score to your analysis or errors

</rule>

<rule>

# After implementing a fix in the code, write a inside the progress-report.txt file notes on what we tried and what we learned and tried to fix and what we implemented. Only needs to be brief but needs to be clear.

</rule>

</rules>
