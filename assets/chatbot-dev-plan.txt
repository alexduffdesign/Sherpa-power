1. Project Specifications Overview
A. Main Chatbot Specifications
Launch Behavior:

Action: Sends a launch request upon the first opening of the chat drawer.
Trace Handling:

Action: Manages all trace types except device_answer.
Conversation History Management:

Action: Saves each chat from the user and assistant to history.
Action: Loads and displays conversation history upon page refresh.
Interactive Last Message:

Action: If the last assistant message is a choice or carousel, retain interactive buttons in the UI, allowing continued user interaction.
Shared Behaviors:

Action: Sends and receives messages, displaying them in the correct chatbot UI.
Action: Initiates a launch when first used.
B. Section Chatbot Specifications
Launch Behavior:

Action: Sends a launch request upon the first focus on the section chatbot's input field.
Trace Handling:

Action: Manages message, choice, and carousel traces, adding them to the UI.
Action: Handles device_answer traces to populate cards inside the applications-grid.
No Conversation History:

Action: Does not maintain or load conversation history.
Variable Management:

Action: Sets Voiceflow variables:
startBlock: Set to "shopifySection".
productDetails: Populates with appropriate information from Liquid templates.
Shared Behaviors:

Action: Sends and receives messages, displaying them in the correct chatbot UI.
Action: Initiates a launch when first used.
Action: When a user clicks a button on a choice or carousel step, sends the choice to the endpoint and deletes the UI elements of that choice or carousel to prevent repeated interactions.
2. Technology Stack
Platform: Shopify Theme
Build Tool: Vite
Languages: JavaScript (ES6+), Liquid
APIs:
Gadget API: Facilitates communication between frontend and backend services.
Voiceflow API: Manages chatbot interactions and trace handling.
Libraries/Tools:
eventemitter3: Implements the Event Bus for decoupled communication.
Custom Web Components: Creates reusable UI elements (buttons, carousels, messages).
3. Proposed File Structure
Organizing your project with a clear and modular file structure enhances maintainability, scalability, and collaboration. Below is the proposed directory layout tailored to your specifications:

bash
Copy code
/shopify-theme
├── /assets
│   ├── /images
│   ├── /styles
│   │   └── chatbot.css
│   └── /scripts
│       ├── /chatbot
│       │   ├── /core
│       │   │   └── chatbot-core.js
│       │   ├── /main
│       │   │   ├── main-chatbot.js
│       │   │   └── main-chatbot-ui.js
│       │   ├── /section
│       │   │   ├── section-chatbot.js
│       │   │   └── section-chatbot-ui.js
│       │   ├── /ui
│       │   │   ├── message-component.js
│       │   │   ├── button-component.js
│       │   │   └── carousel-component.js
│       │   └── /utils
│       │       ├── event-bus.js
│       │       └── event-constants.js
│       ├── chatbot-main.js
│       ├── chatbot-section.js
│       └── index.js
├── /sections
│   ├── chatbot-drawer.liquid
│   └── application.liquid
├── /snippets
│   ├── chatbot-template.liquid
│   └── vite-tag.liquid
├── vite.config.js
├── package.json
└── ... (other Shopify theme files)
A. Directory Breakdown
/assets/scripts/chatbot/

/core/chatbot-core.js: Handles communication with Voiceflow API via Gadget API, processes incoming data, and emits events.
/main/main-chatbot.js: Manages the Main Chatbot logic, including conversation history and UI updates.
/main/main-chatbot-ui.js: Handles UI-specific logic for the Main Chatbot.
/section/section-chatbot.js: Manages the Section Chatbot logic, including trace handling and UI updates.
/section/section-chatbot-ui.js: Handles UI-specific logic for the Section Chatbot.
/ui/: Contains reusable Web Components for messages, buttons, and carousels.
/utils/: Includes utility modules like the Event Bus and event constants.
/assets/scripts/chatbot-main.js: Entry point for initializing the Main Chatbot.

/assets/scripts/chatbot-section.js: Entry point for initializing the Section Chatbot.

/assets/scripts/index.js: Aggregates and exports modules if needed.

/sections/chatbot-drawer.liquid: Liquid template for the chatbot drawer integrating the Main Chatbot.

/sections/application.liquid: Liquid template for the Section Chatbot.

/snippets/chatbot-template.liquid: Reusable Liquid snippet containing the UI template for both chatbots.

/snippets/vite-tag.liquid: Liquid snippet for including Vite-built scripts.

vite.config.js and package.json: Configuration files for Vite and npm dependencies.

B. Rationale Behind the Structure
Modularity: Separating core logic, chatbot-specific logic, and UI components promotes a clean and organized architecture.
Reusability: Web Components in the /ui/ directory can be reused across both chatbots, ensuring consistency.
Maintainability: Organized directories make it easier to locate and update specific functionalities without affecting unrelated parts.
Scalability: Adding new chatbots or features becomes straightforward with this modular setup.
4. Architectural Components
A. Component Interaction Flow
User Interaction:

Main Chatbot: User opens the chat drawer for the first time, triggering a launch event.
Section Chatbot: User focuses on the section chatbot's input for the first time, triggering a separate launch event.
ChatbotCore:

Receives messages or events from both chatbots.
Communicates with Voiceflow API via Gadget API.
Processes incoming traces and emits namespaced events.
Event Bus:

Acts as a mediator, broadcasting events from ChatbotCore to the appropriate chatbot instances.
Chatbots (Main and Section):

Listen to specific events based on their namespaces.
Update their respective UIs using dedicated UI modules and reusable Web Components.
UI Components:

Render messages, buttons, and carousels consistently across both chatbots.
Facilitate user interactions like button clicks and carousel navigations.
B. Event Handling Strategy
Namespaced Events: Utilize unique prefixes for events to ensure that only the intended chatbot responds.

Main Chatbot Events: mainChatbot:messageReceived, mainChatbot:typing, etc.
Section Chatbot Events: sectionChatbot:messageReceived, sectionChatbot:deviceAnswer, etc.
Event Emission: ChatbotCore emits events based on processed traces with appropriate namespaces.

Event Listening: Each chatbot listens only to its respective namespaced events, ensuring isolated and conflict-free operations.

C. Reusable UI Components
message-component.js: Renders user and assistant messages with consistent styling.
button-component.js: Renders interactive buttons with associated payloads.
carousel-component.js: Displays carousel elements, allowing users to navigate through options.
5. Development Steps
A. Step 1: Setup Project Environment
Initialize Project with Vite:

Ensure your Shopify theme is configured to work with Vite for asset bundling.
Initialize npm within your Shopify theme directory if not already done:
bash
Copy code
cd path-to-your-shopify-theme
npm init -y
Install Vite and necessary dependencies:
bash
Copy code
npm install vite eventemitter3
Configure vite.config.js to output assets to Shopify's expected directories.
Create Directory Structure:

Set up the proposed file structure within /assets/scripts/chatbot/ and other relevant directories.
Ensure that Web Components are compatible with Shopify's Liquid templates.
B. Step 2: Implement Event Bus and Event Constants
Create Event Bus:

javascript
Copy code
// /assets/scripts/chatbot/utils/event-bus.js

import EventEmitter from 'eventemitter3';

class EventBus extends EventEmitter {}

const eventBus = new EventBus();

export default eventBus;
Define Event Constants:

javascript
Copy code
// /assets/scripts/chatbot/utils/event-constants.js

export const EVENTS = {
  MAIN_CHATBOT: {
    MESSAGE_RECEIVED: 'mainChatbot:messageReceived',
    TYPING: 'mainChatbot:typing',
    CHOICE_PRESENTED: 'mainChatbot:choicePresented',
    CAROUSEL_PRESENTED: 'mainChatbot:carouselPresented',
    ERROR: 'mainChatbot:error',
    // Add more as needed
  },
  SECTION_CHATBOT: {
    MESSAGE_RECEIVED: 'sectionChatbot:messageReceived',
    DEVICE_ANSWER: 'sectionChatbot:deviceAnswer',
    ERROR: 'sectionChatbot:error',
    // Add more as needed
  }
};
C. Step 3: Develop Reusable UI Components
Message Component (message-component.js):

Functionality: Renders messages from both user and assistant with consistent styling.
Usage: Utilized by both MainChatbotUI and SectionChatbotUI to display messages uniformly.
Button Component (button-component.js):

Functionality: Renders interactive buttons with associated payloads.
Usage: Employed by both chatbots to display choices and actionable buttons.
Carousel Component (carousel-component.js):

Functionality: Displays a carousel of items, each potentially containing images, titles, descriptions, and action buttons.
Usage: Used by both chatbots to present multiple options in an interactive format.
Note: Ensure that these components are accessible and responsive.

D. Step 4: Develop ChatbotCore
ChatbotCore Class (chatbot-core.js):

Responsibilities:
Handles communication with Voiceflow API via Gadget API.
Processes incoming data and emits namespaced events based on trace types.
Manages user sessions and variables like startBlock and productDetails.
Integration with Gadget API:

Utilize the provided Gadget API code to handle POST requests to Voiceflow.
Ensure proper error handling and SSE (Server-Sent Events) management.
Variable Management:

On launch, set variables such as startBlock and productDetails based on the chatbot type (Main or Section).
Incorporate Updated Launch Payload for Section Chatbot:

Example Payload for Section Chatbot Launch:
javascript
Copy code
const interactPayload = {
  action: {
    type: "launch",
    payload: {
      startBlock: "shopifySection",
      productDetails: {
        title: productTitle,
        capacity: productCapacity,
        ac_output_continuous_power: acOutputContinuousPower,
        ac_output_peak_power: acOutputPeakPower,
        dc_output_power: dcOutputPower,
      },
    },
  },
};
E. Step 5: Develop MainChatbot and MainChatbotUI
MainChatbot Class (main-chatbot.js):

Responsibilities:
Initializes ChatbotCore and MainChatbotUI.
Manages conversation history (loading from and saving to local storage).
Listens to namespaced events from ChatbotCore and delegates UI updates to MainChatbotUI.
Handles user inputs and sends messages via ChatbotCore.
MainChatbotUI Class (main-chatbot-ui.js):

Responsibilities:
Manages UI-specific logic for the Main Chatbot.
Utilizes reusable components to render messages, buttons, and carousels.
Implements methods to add, update, and remove UI elements based on events.
Ensures that interactive elements (buttons, carousels) are only clickable once and are removed after interaction.
Conversation History Management:

Action: Saves each user and assistant message to local storage.
Action: Loads conversation history upon page refresh and renders it in the UI.
Action: Retains interactive elements if the last message is a choice or carousel.
Interactive Element Management:

Action: When a user interacts with a choice or carousel, send the choice to the endpoint and remove the interactive elements from the UI.
F. Step 6: Develop SectionChatbot and SectionChatbotUI
SectionChatbot Class (section-chatbot.js):

Responsibilities:
Initializes ChatbotCore and SectionChatbotUI.
Sets Voiceflow variables (startBlock, productDetails) on launch.
Listens to namespaced events from ChatbotCore and delegates UI updates to SectionChatbotUI.
Handles user inputs and sends messages via ChatbotCore.
SectionChatbotUI Class (section-chatbot-ui.js):

Responsibilities:
Manages UI-specific logic for the Section Chatbot.
Utilizes reusable components to render messages, buttons, and carousels.
Implements methods to populate external UI elements like applications-grid based on device_answer traces.
Ensures that interactive elements are only clickable once and are removed after interaction.
Variable Integration:

Action: On launch, set startBlock to "shopifySection" and populate productDetails with data passed from Liquid templates.
Interactive Element Management:

Action: When a user interacts with a choice or carousel, send the choice to the endpoint and remove the interactive elements from the UI.
G. Step 7: Integrate Chatbots into Shopify Liquid Templates
Chatbot Drawer Liquid Template (chatbot-drawer.liquid):

Purpose: Integrates the Main Chatbot within the chatbot drawer.
Implementation:
liquid
Copy code
<!-- /sections/chatbot-drawer.liquid -->

{%- assign drawer_id = 'header-ai-trigger' -%}

<!-- Styling for the chatbot container -->
<style>
  /* Add necessary styles or import from /assets/styles/chatbot.css */
</style>

{% capture form %}
  <form id="main-chatbot-form">
    <input type="text" id="main-chatbot-input" placeholder="Type your message here..." autocomplete="off" required>
    <button type="submit">Send</button>
  </form>
{% endcapture %}

<x-drawer id="{{ drawer_id }}" class="drawer sherpa-guide">
  <div slot="header" class="header-content">
    <div class="header-left">
      <h2 class="h6">SHERPA GUIDE</h2>
      <!-- Include your SVG or logo here -->
    </div>
    <button class="button back-to-start">
      <!-- SVG for back button -->
      Back to Menu
    </button>
  </div>

  <main-chatbot class="main-chatbot-ui" id="main-chatbot-ui">
    <!-- Messages and interactive elements will be rendered here -->
    <footer class="footer-form">
      {{ form }}
    </footer>
  </main-chatbot>
</x-drawer>

{% render 'vite-tag' with 'chatbot-main.js' %}
Section Chatbot Liquid Template (application.liquid):

Purpose: Integrates the Section Chatbot within the application section and passes product details from Liquid.

Implementation:

liquid
Copy code
<!-- /sections/application.liquid -->

<section-chatbot
  product-title="{{ product.title }}"
  product-capacity="{{ product.metafields.custom.capacity | escape }}"
  product-ac_output_continuous_power="{{ product.metafields.custom.ac_output_continuous_power }}"
  product-ac_output_peak_power="{{ product.metafields.custom.ac_output_peak_power }}"
  product-dc_output_power="{{ product.metafields.custom.dc_output_power }}"
  class="section-chatbot section-stack__sidebar">
  {% render 'chatbot-template'
    , is_section_chatbot: section.settings.is_section_chatbot
    , calculator_title: section.settings.calculator_title
    , calculator_subtitle: section.settings.calculator_subtitle
  %}
</section-chatbot>
Notes:

Data Attributes: Pass product details as HTML attributes to the section-chatbot component.
Escaping: Ensure that data passed via Liquid is properly escaped to prevent XSS vulnerabilities.
Chatbot Template Snippet (chatbot-template.liquid):

Purpose: Contains the shared HTML structure for both chatbots.
Implementation:
liquid
Copy code
<!-- /snippets/chatbot-template.liquid -->

<div class="chatbot-container">
  <!-- Chat messages and interactive elements will be rendered here by JS -->
</div>
Vite Tag Snippet (vite-tag.liquid):

Purpose: Facilitates the inclusion of Vite-built scripts within Liquid templates.

Implementation:

liquid
Copy code
<!-- /snippets/vite-tag.liquid -->

<script type="module" src="{{ 'scripts/chatbot/' | asset_url }}{{ include.asset_file }}"></script>
Usage:

In chatbot-drawer.liquid and application.liquid, use {% render 'vite-tag' with 'chatbot-main.js' %} and {% render 'vite-tag' with 'chatbot-section.js' %} respectively to include the necessary scripts.
H. Step 8: Configure Vite for Shopify
Vite Configuration (vite.config.js):

Purpose: Configure Vite to build and output scripts to Shopify's asset directory.
Implementation:
javascript
Copy code
// /vite.config.js

import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    outDir: 'assets/scripts',
    rollupOptions: {
      input: {
        'chatbot-main.js': '/assets/scripts/chatbot-main.js',
        'chatbot-section.js': '/assets/scripts/chatbot-section.js',
      },
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: '[name].js',
        assetFileNames: '[name].[ext]',
      },
    },
  },
});
Build Scripts in package.json:

json
Copy code
// /package.json

{
  "name": "shopify-chatbot",
  "version": "1.0.0",
  "scripts": {
    "build": "vite build",
    "dev": "vite"
  },
  "dependencies": {
    "eventemitter3": "^4.0.7"
  },
  "devDependencies": {
    "vite": "^4.0.0"
  }
}
Run Development Server:

bash
Copy code
npm run dev
Purpose: Launch Vite's development server for live reloading and testing.
Build for Production:

bash
Copy code
npm run build
Purpose: Generate optimized scripts for deployment to Shopify.
I. Step 9: Testing and Quality Assurance
Unit Testing:

Purpose: Test individual modules and components to ensure they function as intended.
Tools: Utilize testing frameworks like Jest or Mocha if applicable.
Integration Testing:

Purpose: Verify that ChatbotCore, both chatbots, and UI handlers interact seamlessly.
Action: Ensure that events are correctly emitted and listened to without interference.
User Acceptance Testing (UAT):

Purpose: Conduct thorough testing from an end-user perspective to identify UX issues.
Action: Validate that all specifications are met:
Launch behaviors for both chatbots.
Trace handling and UI updates.
Conversation history management for the Main Chatbot.
Variable setting for the Section Chatbot.
Error Handling Verification:

Purpose: Simulate API failures and trace handling errors to ensure graceful degradation.
Action: Confirm that error messages are displayed appropriately without breaking the UI.
Performance Testing:

Purpose: Assess load times, message rendering speeds, and responsiveness across devices.
Action: Optimize where necessary to enhance user experience.
Accessibility Testing:

Purpose: Ensure that chatbots are accessible to users with disabilities.
Action: Implement and verify ARIA attributes, keyboard navigation, and screen reader compatibility.
J. Step 10: Deployment and Monitoring
Deploy to Shopify:

Action: Upload the built scripts and updated Liquid templates to your Shopify theme.
Verification: Ensure that assets are correctly referenced and loaded.
Final Validation:

Action: After deployment, perform final checks to ensure all functionalities work as expected.
Scope: Test on different browsers and devices to ensure compatibility.
Monitor Performance:

Action: Use analytics tools to monitor chatbot performance, user interactions, and system health.
Tools: Consider integrating tools like Google Analytics or custom monitoring solutions.
Gather User Feedback:

Action: Collect feedback from users to identify areas for improvement.
Method: Utilize surveys, feedback forms, or direct user interactions.
Iterate Based on Feedback:

Action: Refine chatbot functionalities and UI based on user feedback and testing outcomes.
K. Step 11: Documentation and Maintenance
Code Documentation:

Action: Comment complex logic within JavaScript files.
Action: Document the purpose and usage of each Web Component and class.
README File:

Content:
Project overview
Setup instructions
Build and deployment steps
File structure explanation
Usage guidelines
Regular Maintenance:

Action: Keep dependencies updated to their latest versions.
Action: Perform periodic code reviews to maintain code quality.
Action: Refactor code to adhere to best practices and improve readability.
6. Detailed UI Architecture Breakdown
A. Reusable UI Components
Message Component (message-component.js):

Functionality: Renders messages from both user and assistant with consistent styling.
Usage: Utilized by both MainChatbotUI and SectionChatbotUI to display messages uniformly.
Button Component (button-component.js):

Functionality: Renders interactive buttons with associated payloads.
Usage: Employed by both chatbots to display choices and actionable buttons.
Carousel Component (carousel-component.js):

Functionality: Displays a carousel of items, each potentially containing images, titles, descriptions, and action buttons.
Usage: Used by both chatbots to present multiple options in an interactive format.
B. Dedicated UI Handlers
MainChatbotUI (main-chatbot-ui.js):

Responsibilities:
Rendering Messages: Utilizes message-component.js to display conversation history.
Interactive Elements: Uses button-component.js and carousel-component.js to render choices and carousels.
Conversation History: Manages loading from and saving to local storage.
Interactive Element Persistence: Ensures that if the last message is a choice or carousel, interactive buttons are retained and clickable only once.
Methods:
addMessage(sender, content)
addButtons(buttons)
addCarousel(items)
showTypingIndicator()
hideTypingIndicator()
displayError(message)
removeInteractiveElements()
SectionChatbotUI (section-chatbot-ui.js):

Responsibilities:
Rendering Messages: Utilizes message-component.js to display messages.
Interactive Elements: Uses button-component.js and carousel-component.js to render choices and carousels.
Device Answer Handling: Populates applications-grid with device information based on device_answer traces.
Variable Management: Sets Voiceflow variables (startBlock, productDetails) using data from Liquid templates.
Methods:
addMessage(sender, content)
addButtons(buttons)
addCarousel(items)
populateApplicationsGrid(devices)
displayError(message)
removeInteractiveElements()
C. Implementation Considerations
Shared Functionality:

Both UI Handlers leverage the same Web Components, ensuring consistency across chatbots.
Variable Integration:

Section Chatbot: Passes dynamic productDetails from Liquid to JavaScript via HTML attributes, ensuring that Voiceflow receives accurate product information.
Event Emission from UI Handlers:

UI Handlers emit events when users interact with UI elements (e.g., clicking a button), which the respective chatbot classes listen to and handle accordingly.
Interactive Element Management:

After a user interacts with a choice or carousel, the corresponding UI elements are removed to prevent repeated interactions.
7. Gadget API Integration
A. Understanding the Current Gadget API Code
Your current Gadget API code (POST-voiceflow-stream.js) serves as a bridge between your frontend chatbots and the Voiceflow API. Here's a breakdown of its functionality:

Request Handling:

Receives POST requests containing userID, action, and config.
SSE (Server-Sent Events) Setup:

Sets up headers to support SSE with CORS.
Voiceflow API Communication:

Constructs the Voiceflow API endpoint using VF_PROJECT_ID and sends the action payload.
Streaming Response Handling:

Reads the streaming response from Voiceflow and forwards it to the client in real-time.
Error Handling:

Catches and logs errors, sending appropriate error messages back to the client.
B. Integration with ChatbotCore
ChatbotCore Responsibilities:

Sending Actions: Sends launch requests and user messages to the Gadget API endpoint.
Receiving Responses: Processes incoming traces from Voiceflow and emits namespaced events via the Event Bus.
Variable Management: Includes variables like startBlock and productDetails in the payload when initiating a launch.
Example Payload for Section Chatbot Launch:

javascript
Copy code
const productDetails = JSON.stringify({
  title: productTitle,
  capacity: productCapacity,
  ac_output_continuous_power: acOutputContinuousPower,
  ac_output_peak_power: acOutputPeakPower,
  dc_output_power: dcOutputPower,
});

const interactPayload = {
  action: {
    type: "launch",
    payload: {
      startBlock: "shopifySection",
      productDetails: productDetails,
    },
  },
};
Ensuring Proper Variable Setting:

Main Chatbot: Sets startBlock to "mainChatbot" (if applicable) and omits productDetails.
Section Chatbot: Sets startBlock to "shopifySection" and includes productDetails based on Liquid data.
C. Enhancing Gadget API Code (Optional Enhancements)
Security:

Ensure that API keys and sensitive information are securely managed and not exposed on the client side.
Scalability:

Optimize the API to handle multiple concurrent streams efficiently.
Logging and Monitoring:

Implement comprehensive logging to monitor API usage and quickly identify issues.
8. Updated Development Steps
A. Step-by-Step Implementation Guide
Step 1: Finalize Reusable UI Components
Finalize Components:

Ensure that message-component.js, button-component.js, and carousel-component.js are fully functional, accessible, and styled consistently.
Accessibility:

Implement ARIA attributes and keyboard navigation support within Web Components.
Responsive Design:

Ensure components adapt seamlessly across different devices and screen sizes.
Step 2: Develop Dedicated UI Handlers
MainChatbotUI (main-chatbot-ui.js):

Methods:
addMessage(sender, content)
addButtons(buttons)
addCarousel(items)
showTypingIndicator()
hideTypingIndicator()
displayError(message)
removeInteractiveElements()
Responsibilities:
Render conversation history.
Manage interactive elements with single-use functionality.
Handle scrolling and UI updates.
SectionChatbotUI (section-chatbot-ui.js):

Methods:
addMessage(sender, content)
addButtons(buttons)
addCarousel(items)
populateApplicationsGrid(devices)
displayError(message)
removeInteractiveElements()
Responsibilities:
Render messages and interactive elements.
Populate applications-grid based on device_answer traces.
Manage Voiceflow variables (startBlock, productDetails).
Step 3: Refactor ChatbotCore
Enhance Variable Management:

Modify ChatbotCore to accept and include variables (startBlock, productDetails) in the payload during launch requests.
Event Emission:

Ensure that ChatbotCore correctly emits namespaced events based on the type of trace received.
Error Handling:

Improve error messages and handling to provide clear feedback to both chatbots.
Step 4: Refactor MainChatbot and SectionChatbot
MainChatbot (main-chatbot.js):

Initialization:

Instantiate ChatbotCore with the appropriate endpoint.
Instantiate MainChatbotUI and link it to the UI container.
Load conversation history from local storage if available.
Event Listening:

Listen to mainChatbot:* events and delegate UI updates to MainChatbotUI.
User Interaction Handling:

Capture user messages from the UI and send them via ChatbotCore.
SectionChatbot (section-chatbot.js):

Initialization:

Instantiate ChatbotCore with the appropriate endpoint.
Instantiate SectionChatbotUI and link it to the UI container.
Retrieve productDetails from Liquid data passed via HTML attributes.
Event Listening:

Listen to sectionChatbot:* events and delegate UI updates to SectionChatbotUI.
User Interaction Handling:

Capture user messages from the UI and send them via ChatbotCore.
Variable Setting:

On launch, set startBlock to "shopifySection" and populate productDetails with data from Liquid.
Interactive Element Management:

Action: When a user interacts with a choice or carousel, send the choice to the endpoint and remove the interactive elements from the UI.
Step 5: Integrate Chatbots into Shopify Liquid Templates
Chatbot Drawer Liquid Template (chatbot-drawer.liquid):

Implementation:
liquid
Copy code
<!-- /sections/chatbot-drawer.liquid -->

{%- assign drawer_id = 'header-ai-trigger' -%}

<!-- Styling for the chatbot container -->
<style>
  /* Add necessary styles or import from /assets/styles/chatbot.css */
</style>

{% capture form %}
  <form id="main-chatbot-form">
    <input type="text" id="main-chatbot-input" placeholder="Type your message here..." autocomplete="off" required>
    <button type="submit">Send</button>
  </form>
{% endcapture %}

<x-drawer id="{{ drawer_id }}" class="drawer sherpa-guide">
  <div slot="header" class="header-content">
    <div class="header-left">
      <h2 class="h6">SHERPA GUIDE</h2>
      <!-- Include your SVG or logo here -->
    </div>
    <button class="button back-to-start">
      <!-- SVG for back button -->
      Back to Menu
    </button>
  </div>

  <main-chatbot class="main-chatbot-ui" id="main-chatbot-ui">
    <!-- Messages and interactive elements will be rendered here -->
    <footer class="footer-form">
      {{ form }}
    </footer>
  </main-chatbot>
</x-drawer>

{% render 'vite-tag' with 'chatbot-main.js' %}
Section Chatbot Liquid Template (application.liquid):

Implementation:

liquid
Copy code
<!-- /sections/application.liquid -->

<section-chatbot
  product-title="{{ product.title }}"
  product-capacity="{{ product.metafields.custom.capacity | escape }}"
  product-ac_output_continuous_power="{{ product.metafields.custom.ac_output_continuous_power }}"
  product-ac_output_peak_power="{{ product.metafields.custom.ac_output_peak_power }}"
  product-dc_output_power="{{ product.metafields.custom.dc_output_power }}"
  class="section-chatbot section-stack__sidebar">
  {% render 'chatbot-template'
    , is_section_chatbot: section.settings.is_section_chatbot
    , calculator_title: section.settings.calculator_title
    , calculator_subtitle: section.settings.calculator_subtitle
  %}
</section-chatbot>
Notes:

Data Attributes: Pass product details as HTML attributes to the section-chatbot component.
Escaping: Ensure that data passed via Liquid is properly escaped to prevent XSS vulnerabilities.
Chatbot Template Snippet (chatbot-template.liquid):

Purpose: Contains the shared HTML structure for both chatbots.
Implementation:
liquid
Copy code
<!-- /snippets/chatbot-template.liquid -->

<div class="chatbot-container">
  <!-- Chat messages and interactive elements will be rendered here by JS -->
</div>
Vite Tag Snippet (vite-tag.liquid):

Purpose: Facilitates the inclusion of Vite-built scripts within Liquid templates.

Implementation:

liquid
Copy code
<!-- /snippets/vite-tag.liquid -->

<script type="module" src="{{ 'scripts/chatbot/' | asset_url }}{{ include.asset_file }}"></script>
Usage:

In chatbot-drawer.liquid and application.liquid, use {% render 'vite-tag' with 'chatbot-main.js' %} and {% render 'vite-tag' with 'chatbot-section.js' %} respectively to include the necessary scripts.
Step 6: Configure Vite for Shopify
Vite Configuration (vite.config.js):

Implementation:
javascript
Copy code
// /vite.config.js

import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    outDir: 'assets/scripts',
    rollupOptions: {
      input: {
        'chatbot-main.js': '/assets/scripts/chatbot-main.js',
        'chatbot-section.js': '/assets/scripts/chatbot-section.js',
      },
      output: {
        entryFileNames: '[name].js',
        chunkFileNames: '[name].js',
        assetFileNames: '[name].[ext]',
      },
    },
  },
});
Build Scripts in package.json:

json
Copy code
// /package.json

{
  "name": "shopify-chatbot",
  "version": "1.0.0",
  "scripts": {
    "build": "vite build",
    "dev": "vite"
  },
  "dependencies": {
    "eventemitter3": "^4.0.7"
  },
  "devDependencies": {
    "vite": "^4.0.0"
  }
}
Run Development Server:

bash
Copy code
npm run dev
Purpose: Launch Vite's development server for live reloading and testing.
Build for Production:

bash
Copy code
npm run build
Purpose: Generate optimized scripts for deployment to Shopify.
Step 7: Testing and Quality Assurance
Unit Testing:

Purpose: Test individual modules and components to ensure they function as intended.
Tools: Utilize testing frameworks like Jest or Mocha if applicable.
Integration Testing:

Purpose: Verify that ChatbotCore, both chatbots, and UI handlers interact seamlessly.
Action: Ensure that events are correctly emitted and listened to without interference.
User Acceptance Testing (UAT):

Purpose: Conduct thorough testing from an end-user perspective to identify UX issues.
Action: Validate that all specifications are met:
Launch behaviors for both chatbots.
Trace handling and UI updates.
Conversation history management for the Main Chatbot.
Variable setting for the Section Chatbot.
Error Handling Verification:

Purpose: Simulate API failures and trace handling errors to ensure graceful degradation.
Action: Confirm that error messages are displayed appropriately without breaking the UI.
Performance Testing:

Purpose: Assess load times, message rendering speeds, and responsiveness across devices.
Action: Optimize where necessary to enhance user experience.
Accessibility Testing:

Purpose: Ensure that chatbots are accessible to users with disabilities.
Action: Implement and verify ARIA attributes, keyboard navigation, and screen reader compatibility.
Step 8: Deployment and Monitoring
Deploy to Shopify:

Action: Upload the built scripts and updated Liquid templates to your Shopify theme.
Verification: Ensure that assets are correctly referenced and loaded.
Final Validation:

Action: After deployment, perform final checks to ensure all functionalities work as expected.
Scope: Test on different browsers and devices to ensure compatibility.
Monitor Performance:

Action: Use analytics tools to monitor chatbot performance, user interactions, and system health.
Tools: Consider integrating tools like Google Analytics or custom monitoring solutions.
Gather User Feedback:

Action: Collect feedback from users to identify areas for improvement.
Method: Utilize surveys, feedback forms, or direct user interactions.
Iterate Based on Feedback:

Action: Refine chatbot functionalities and UI based on user feedback and testing outcomes.
Step 9: Documentation and Maintenance
Code Documentation:

Action: Comment complex logic within JavaScript files.
Action: Document the purpose and usage of each Web Component and class.
README File:

Content:
Project overview
Setup instructions
Build and deployment steps
File structure explanation
Usage guidelines
Regular Maintenance:

Action: Keep dependencies updated to their latest versions.
Action: Perform periodic code reviews to maintain code quality.
Action: Refactor code to adhere to best practices and improve readability.
9. Finalizing the Plan with Product Details Integration
A. Addressing Variable Management in Section Chatbot
Passing Liquid Data via HTML Attributes:

Implementation in application.liquid:

liquid
Copy code
<section-chatbot
  product-title="{{ product.title }}"
  product-capacity="{{ product.metafields.custom.capacity | escape }}"
  product-ac_output_continuous_power="{{ product.metafields.custom.ac_output_continuous_power }}"
  product-ac_output_peak_power="{{ product.metafields.custom.ac_output_peak_power }}"
  product-dc_output_power="{{ product.metafields.custom.dc_output_power }}"
  class="section-chatbot section-stack__sidebar">
  {% render 'chatbot-template'
    , is_section_chatbot: section.settings.is_section_chatbot
    , calculator_title: section.settings.calculator_title
    , calculator_subtitle: section.settings.calculator_subtitle
  %}
</section-chatbot>
Explanation:

Data Attributes: Pass product-related data as HTML attributes to the section-chatbot component.
Escaping: Use Liquid's escape filter to prevent XSS attacks by sanitizing user-generated content.
Accessing Data Attributes in JavaScript:

In section-chatbot-ui.js:

javascript
Copy code
constructor(container) {
  super();
  this.container = container;
  this.productTitle = this.getAttribute('product-title');
  this.productCapacity = this.getAttribute('product-capacity');
  this.acOutputContinuousPower = this.getAttribute('product-ac_output_continuous_power');
  this.acOutputPeakPower = this.getAttribute('product-ac_output_peak_power');
  this.dcOutputPower = this.getAttribute('product-dc_output_power');

  this.startBlock = 'shopifySection';
  this.productDetails = {
    title: this.productTitle,
    capacity: this.productCapacity,
    ac_output_continuous_power: this.acOutputContinuousPower,
    ac_output_peak_power: this.acOutputPeakPower,
    dc_output_power: this.dcOutputPower,
  };

  // Additional initialization...
}
Explanation:

Attribute Retrieval: Access product details passed via HTML attributes.
Variable Setting: Initialize startBlock and productDetails based on retrieved attributes.
Including Variables in Launch Payload:

In section-chatbot.js:

javascript
Copy code
initializeLaunch() {
  if (!this.hasLaunched) {
    const interactPayload = {
      action: {
        type: "launch",
        payload: {
          startBlock: this.ui.startBlock,
          productDetails: this.ui.productDetails,
        },
      },
    };

    this.core.sendLaunch(interactPayload);
    this.hasLaunched = true;
  }
}
Explanation:

Payload Composition: Include startBlock and productDetails in the launch payload.
Action: Send the launch request with the necessary variables to Voiceflow via ChatbotCore.
B. Managing Interactive Elements Post-Interaction
Button Click Handling:

Action: When a user clicks on a button within a choice or carousel, send the selected choice to the endpoint and remove the interactive elements from the UI.
Implementation in UI Handlers:

In main-chatbot-ui.js and section-chatbot-ui.js:

javascript
Copy code
addButtons(buttons) {
  buttons.forEach(buttonData => {
    const button = document.createElement('button-component');
    button.dataset.label = buttonData.name;
    button.dataset.payload = JSON.stringify(buttonData.request);
    this.container.appendChild(button);
  });

  this.container.addEventListener('click', (e) => {
    if (e.target.closest('button-component')) {
      const button = e.target.closest('button-component');
      const payload = JSON.parse(button.dataset.payload);
      this.emit('buttonClicked', payload);
      this.removeInteractiveElements();
    }
  });
}
Remove Interactive Elements Method:

javascript
Copy code
removeInteractiveElements() {
  const interactiveElements = this.container.querySelectorAll('button-component, carousel-component');
  interactiveElements.forEach(element => element.remove());
}
Chatbot Classes Handling Button Clicks:

MainChatbot (main-chatbot.js):

javascript
Copy code
mainChatbotUI.addEventListener('buttonClicked', (e) => {
  const payload = e.detail;
  this.handleUserMessage(JSON.stringify(payload));
});
SectionChatbot (section-chatbot.js):

javascript
Copy code
sectionChatbotUI.addEventListener('buttonClicked', (e) => {
  const payload = e.detail;
  this.handleUserMessage(JSON.stringify(payload));
});
Explanation:

Event Listening: Chatbot classes listen to buttonClicked events emitted by their respective UI handlers.
Action: Upon receiving a buttonClicked event, send the payload to ChatbotCore for processing and communication with Voiceflow.
10. Additional Recommendations
A. Maintain Clear Separation of Concerns
ChatbotCore:

Responsibilities: Communication with APIs, processing data, emitting events.
Avoid: Direct DOM manipulation or handling storage.
MainChatbot and SectionChatbot:

Responsibilities: Managing specific chatbot logic, handling events, delegating UI updates to respective UI handlers.
Avoid: Direct API communication or data processing beyond their scope.
UI Handlers (main-chatbot-ui.js and section-chatbot-ui.js):

Responsibilities: Rendering UI elements based on events, managing user interactions.
Avoid: Business logic or data management beyond UI concerns.
B. Leverage Reusable Components
Web Components: Utilize custom elements for shared UI elements to promote consistency and reduce code duplication.
Flexibility: Ensure that these components are flexible enough to accommodate both chatbots' needs.
C. Adopt Robust Event-Driven Communication
Centralized Event Bus: Utilize a centralized Event Bus with namespaced events to facilitate decoupled and scalable communication between components.
Consistent Naming Conventions: Maintain clear and consistent event naming conventions to enhance code readability and maintainability.
D. Prioritize User Experience and Accessibility
Accessibility Best Practices: Implement ARIA attributes, keyboard navigation, and screen reader compatibility to ensure inclusivity.
Responsive Design: Ensure that chatbots adapt seamlessly across various device sizes and orientations.
Visual Feedback: Provide clear visual indicators for actions like message sending, loading states, and errors to enhance user experience.
E. Ensure Comprehensive Testing
Testing Phases: Conduct extensive testing at multiple levels (unit, integration, UAT) to identify and rectify issues early.
Performance Optimization: Monitor and optimize load times, message rendering speeds, and responsiveness to deliver a smooth user experience.
F. Document and Maintain the Codebase
Code Documentation: Maintain thorough documentation for all components and modules to facilitate future development and onboarding.
README Update: Include setup instructions, architectural overviews, and usage guidelines.
Regular Maintenance: Keep dependencies updated and perform periodic code reviews to maintain code quality and security.
11. Final Thoughts
By adhering to this comprehensive development plan, you will establish a robust, maintainable, and scalable chatbot integration within your Shopify theme. The clear separation of concerns, combined with reusable UI components and a robust event-driven architecture, ensures that both the Main Chatbot and Section Chatbot operate seamlessly within their defined scopes.

Key Highlights:
Modular File Structure: Facilitates easy maintenance and scalability.
Event-Driven Architecture: Promotes decoupling and prevents cross-chatbot interference.
Reusable UI Components: Ensures consistency and reduces code duplication.
Clear Separation of Responsibilities: Each component handles its specific functionalities without overlapping.
Comprehensive Testing: Ensures reliability and a smooth user experience.
Next Steps:
Implement the Proposed File Structure.
Develop and Integrate the Event Bus and UI Components.
Refactor ChatbotCore, MainChatbot, and SectionChatbot According to Specifications.
Conduct Thorough Testing and Validation.
Deploy to Shopify and Monitor Performance.
Iterate Based on Feedback and Testing Outcomes.
If you need further assistance with specific implementations, configurations, or troubleshooting during development, feel free to reach out. I'm here to help you achieve a seamless and effective chatbot integration!


Gadget API Code: 

// routes/POST-voiceflow-stream.js
export default async function route({ request, reply }) {
  const logger = request.logger;
  const { userID, action } = request.body;

  // Set headers for SSE with CORS support
  reply.raw.writeHead(200, {
    "Content-Type": "text/event-stream",
    "Cache-Control": "no-cache",
    Connection: "keep-alive",
    "Access-Control-Allow-Origin": request.headers.origin || "*",
    "Access-Control-Allow-Credentials": "true",
  });

  const vfProjectId = process.env.VF_PROJECT_ID;
  const VF_API_KEY = process.env.VF_API_KEY;

  if (!vfProjectId || !VF_API_KEY) {
    logger.error("Missing required environment variables");
    reply.raw.write(
      `data: ${JSON.stringify({
        type: "error",
        payload: { message: "Server configuration error" },
      })}\n\n`
    );
    reply.raw.end();
    return;
  }

  const streamUrl = `https://general-runtime.voiceflow.com/v2/project/${vfProjectId}/user/${userID}/interact/stream`;

  try {
    const response = await fetch(streamUrl, {
      method: "POST",
      headers: {
        Accept: "text/event-stream",
        Authorization: VF_API_KEY,
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        action,
        config: request.body.config,
      }),
    });

    if (!response.ok) {
      throw new Error(`Voiceflow API error: ${response.status}`);
    }

    // Set up streaming with proper error handling
    const reader = response.body.getReader();

    request.raw.on("close", () => {
      reader.cancel();
      reply.raw.end();
    });

    try {
      while (true) {
        const { value, done } = await reader.read();

        if (done) {
          reply.raw.end();
          break;
        }

        // Forward the chunk to the client
        reply.raw.write(new TextDecoder().decode(value));
      }
    } catch (streamError) {
      logger.error(
        {
          error: streamError.message,
          stack: streamError.stack,
        },
        "Error during stream processing"
      );

      reply.raw.write(
        `data: ${JSON.stringify({
          type: "error",
          payload: { message: "Stream processing error" },
        })}\n\n`
      );
      reply.raw.end();
    }
  } catch (error) {
    logger.error(
      {
        error: error.message,
        stack: error.stack,
      },
      "Error in streaming request"
    );

    reply.raw.write(
      `data: ${JSON.stringify({
        type: "error",
        payload: { message: error.message },
      })}\n\n`
    );
    reply.raw.end();
  }
}

route.options = {
  preflight: true,
  schema: {
    body: {
      type: "object",
      required: ["userID", "action"],
      properties: {
        userID: { type: "string" },
        action: { type: "object" },
        config: { type: "object" },
      },
    },
  },
};
