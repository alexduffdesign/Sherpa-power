{"version":3,"file":"base-chatbot.Dq_B-Nkt.js","sources":["../frontend/baseChatbot/base-chatbot.js"],"sourcesContent":["// /assets/scripts/chatbot/core/base-chatbot.js\n\nimport EventEmitter from \"eventemitter3\";\nimport { StreamingMarkdownParser } from \"../utils/streaming-markdown-parser.js\"; // Ensure correct path\nimport { parseMarkdown } from \"../utils/markdown-util.js\"; // Import parseMarkdown\n\n/**\n * ChatbotCore Class\n * Handles communication with Voiceflow API via Gadget middleware and processes responses\n */\nclass ChatbotCore {\n  /**\n   * @param {Object} config - Configuration object\n   * @param {string} config.type - Type of chatbot ('main' or 'section')\n   * @param {string} config.endpoint - API endpoint URL\n   * @param {string} config.userID - Unique user identifier\n   */\n  constructor(config) {\n    if (!config.userID) {\n      throw new Error(\"ChatbotCore requires a userID\");\n    }\n    if (!config.endpoint) {\n      throw new Error(\"ChatbotCore requires an endpoint URL\");\n    }\n    if (!config.type) {\n      throw new Error(\"ChatbotCore requires a type ('main' or 'section')\");\n    }\n\n    this.userID = config.userID;\n    this.endpoint = config.endpoint;\n    this.type = config.type;\n    this.eventBus = new EventEmitter();\n    this.abortController = null;\n    this.currentCompletion = null; // For handling completion events\n    this.setupInteractiveElementHandling();\n\n    // Initialize Streaming Markdown Parser\n    this.streamingParser = new StreamingMarkdownParser((htmlSegment) => {\n      this.eventBus.emit(\"assistantMessageStreamed\", { content: htmlSegment });\n    });\n  }\n\n  /**\n   * Sends a launch request to initiate the conversation\n   * @param {Object} interactPayload - Optional payload for launch\n   */\n  async sendLaunch(interactPayload = {}) {\n    console.log(\"Constructing launch payload:\", interactPayload);\n    const payload = interactPayload.action\n      ? interactPayload\n      : {\n          action: {\n            type: \"launch\",\n          },\n        };\n\n    return this.sendAction(payload);\n  }\n\n  /**\n   * Sends a user message to the chatbot\n   * @param {string | Object} message - The user's message or button payload\n   */\n  async sendMessage(message) {\n    console.log(\"Message payload:\", message);\n    const payload = {\n      action: {\n        type: \"text\",\n        payload: typeof message === \"object\" ? message : message,\n      },\n    };\n\n    return this.sendAction(payload);\n  }\n\n  /**\n   * Sends an action to the Voiceflow API via Gadget\n   * @param {Object} actionPayload - The action payload to send\n   */\n  async sendAction(actionPayload) {\n    try {\n      // Only abort if there's an existing connection\n      if (this.abortController) {\n        this.abortController.abort();\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n\n      this.abortController = new AbortController();\n      const { signal } = this.abortController;\n\n      // Show typing indicator\n      this.eventBus.emit(\"typing\", { isTyping: true });\n\n      const response = await fetch(this.endpoint, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"text/event-stream\",\n        },\n        body: JSON.stringify({\n          userID: this.userID,\n          action: actionPayload.action,\n        }),\n        credentials: \"include\",\n        signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`API responded with status ${response.status}`);\n      }\n\n      await this.handleSSEResponse(response);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        console.debug(\"Request aborted, new request in progress\");\n        return;\n      }\n      this.handleError(error);\n    }\n  }\n\n  setupInteractiveElementHandling() {\n    this.eventBus.on(\"interactiveElementClicked\", (payload) => {\n      // Now both button types will have payload.label\n      const userMessage = payload.label || \"Button clicked\";\n      this.eventBus.emit(\"userMessage\", userMessage);\n      this.handleInteractiveElementAction(payload, userMessage);\n    });\n  }\n\n  async handleInteractiveElementAction(payload, userMessage) {\n    if (payload.type && payload.type.startsWith(\"path-\")) {\n      const actionPayload = {\n        action: {\n          type: payload.type,\n          payload: {\n            label: userMessage,\n          },\n        },\n      };\n      return this.sendAction(actionPayload);\n    } else if (payload.type === \"intent\") {\n      const actionPayload = {\n        action: {\n          type: \"intent\",\n          payload: {\n            intent: payload.payload.intent,\n            query: payload.payload.query || \"\",\n            entities: payload.payload.entities || [],\n          },\n        },\n      };\n      return this.sendAction(actionPayload);\n    } else if (payload.type === \"button\") {\n      const requestPayload = {\n        action: {\n          type: \"button\",\n          payload: actionData,\n        },\n      };\n      this.core.sendAction(requestPayload);\n    } else if (payload.action) {\n      // Handle carousel button clicks\n      return this.sendAction({ action: payload.action });\n    } else {\n      // Fallback to just sending userMessage as text if unknown\n      const requestPayload = {\n        request: {\n          type: \"text\",\n          payload: userMessage,\n        },\n      };\n      this.core.sendAction(requestPayload);\n    }\n  }\n\n  /**\n   * Handles the SSE response from the API\n   * @private\n   * @param {Response} response - Fetch API response object\n   */\n  async handleSSEResponse(response) {\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder(\"utf-8\");\n    let buffer = \"\";\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          this.eventBus.emit(\"end\", {});\n          break;\n        }\n\n        buffer += decoder.decode(value, { stream: true });\n        const events = buffer.split(\"\\n\\n\");\n        buffer = events.pop();\n\n        events.forEach((eventStr) => {\n          if (eventStr.trim() === \"\") return;\n          this.processEventString(eventStr);\n        });\n      }\n    } catch (error) {\n      this.handleError(error);\n    } finally {\n      this.eventBus.emit(\"typing\", { isTyping: false });\n    }\n  }\n\n  /**\n   * Process an individual SSE event string\n   * @private\n   * @param {string} eventStr - The event string to process\n   */\n  processEventString(eventStr) {\n    try {\n      const lines = eventStr.split(\"\\n\");\n      const eventTypeLine = lines.find((line) => line.startsWith(\"event:\"));\n      const dataLine = lines.find((line) => line.startsWith(\"data:\"));\n      console.log(\"eventTypeLine:\", eventTypeLine); // Add this log\n\n      const eventType = eventTypeLine\n        ? eventTypeLine.split(\":\")[1].trim()\n        : \"trace\";\n      const data = dataLine\n        ? JSON.parse(eventStr.substring(eventStr.indexOf(\"data:\") + 5).trim())\n        : null;\n\n      switch (eventType) {\n        case \"trace\":\n          this.processTrace(data);\n          console.log(\"ProcessTrace\", data);\n          break;\n        case \"completion\":\n          this.handleCompletion(data);\n          console.log(\"Completion event received\", data);\n          break;\n      }\n    } catch (error) {\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Process a trace event from Voiceflow\n   * @protected\n   * @param {Object} trace - The trace object to process\n   */\n  processTrace(trace) {\n    if (!trace.type) {\n      console.warn(\"Trace without type received:\", trace);\n      return;\n    }\n\n    console.log(\"processTrace called with:\", trace);\n\n    switch (trace.type) {\n      case \"text\":\n        this.eventBus.emit(\"assistantMessageNonStreamed\", {\n          content: trace.payload.message,\n          metadata: trace.payload.metadata,\n        });\n        break;\n      case \"choice\":\n        this.eventBus.emit(\"choicePresented\", {\n          buttons: trace.payload.buttons,\n        });\n        break;\n      case \"carousel\":\n        this.eventBus.emit(\"carouselPresented\", {\n          type: \"carousel\",\n          items: trace.payload.cards,\n        });\n        break;\n      case \"device_answer\":\n        if (this.type === \"section\") {\n          this.eventBus.emit(\"deviceAnswer\", trace.payload);\n        }\n        break;\n      default:\n        console.warn(`Unhandled trace type: ${trace.type}`, trace);\n    }\n  }\n\n  /**\n   * Handle completion trace events for streaming\n   * @private\n   * @param {Object} payload - The payload from completion trace\n   */\n  handleCompletion(payload) {\n    if (!payload || !payload.state) {\n      console.warn(\"Invalid completion payload:\", payload);\n      return;\n    }\n\n    switch (payload.state) {\n      case \"start\":\n        this.currentCompletion = \"\";\n        // Initialize parser state if needed\n        break;\n\n      case \"content\":\n        if (payload.content) {\n          // Instead of accumulating raw text:\n          this.currentCompletion += payload.content;\n          // Feed the content directly into the parser\n          this.streamingParser.appendText(payload.content);\n          console.log(\"appendText called with:\", payload.content);\n        }\n        break;\n\n      case \"end\":\n        // Parser flush\n        this.streamingParser.end();\n\n        const finalHTML = parseMarkdown(this.currentCompletion); // Use parseMarkdown instead of window.marked\n        this.eventBus.emit(\"finalMessage\", {\n          content: finalHTML,\n          isStreamed: true,\n        });\n        // Emit a new event specifically for history saving\n        this.eventBus.emit(\"assistantMessageFinalized\", {\n          content: finalHTML,\n          metadata: null,\n        });\n        this.currentCompletion = null;\n        break;\n\n      default:\n        console.warn(\"Unknown completion state:\", payload.state);\n    }\n  }\n\n  /**\n   * Emit a complete message received\n   * @private\n   * @param {string} message - The message content\n   * @param {Object} metadata - Optional metadata\n   */\n  emitMessageReceived(message, metadata) {\n    this.eventBus.emit(\"messageReceived\", {\n      content: message,\n      metadata,\n      isStreamed: false,\n    });\n  }\n\n  /**\n   * Handle errors in the chatbot\n   * @private\n   * @param {Error} error - The error to handle\n   */\n  handleError(error) {\n    console.error(\"Chatbot error:\", error);\n    this.eventBus.emit(\"error\", { message: error.message });\n    this.eventBus.emit(\"typing\", { isTyping: false });\n  }\n\n  /**\n   * Clean up resources\n   * @public\n   */\n  destroy() {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n    this.eventBus.removeAllListeners();\n  }\n}\n\nexport default ChatbotCore;\n"],"names":["ChatbotCore","config","EventEmitter","StreamingMarkdownParser","htmlSegment","interactPayload","payload","message","actionPayload","resolve","signal","response","error","userMessage","requestPayload","reader","decoder","buffer","done","value","events","eventStr","lines","eventTypeLine","line","dataLine","eventType","data","trace","finalHTML","parseMarkdown","metadata"],"mappings":"gGAUA,MAAMA,CAAY,CAOhB,YAAYC,EAAQ,CAClB,GAAI,CAACA,EAAO,OACV,MAAM,IAAI,MAAM,+BAA+B,EAEjD,GAAI,CAACA,EAAO,SACV,MAAM,IAAI,MAAM,sCAAsC,EAExD,GAAI,CAACA,EAAO,KACV,MAAM,IAAI,MAAM,mDAAmD,EAGrE,KAAK,OAASA,EAAO,OACrB,KAAK,SAAWA,EAAO,SACvB,KAAK,KAAOA,EAAO,KACnB,KAAK,SAAW,IAAIC,EACpB,KAAK,gBAAkB,KACvB,KAAK,kBAAoB,KACzB,KAAK,gCAA+B,EAGpC,KAAK,gBAAkB,IAAIC,EAAyBC,GAAgB,CAClE,KAAK,SAAS,KAAK,2BAA4B,CAAE,QAASA,CAAW,CAAE,CAC7E,CAAK,CACF,CAMD,MAAM,WAAWC,EAAkB,GAAI,CACrC,QAAQ,IAAI,+BAAgCA,CAAe,EAC3D,MAAMC,EAAUD,EAAgB,OAC5BA,EACA,CACE,OAAQ,CACN,KAAM,QACP,CACX,EAEI,OAAO,KAAK,WAAWC,CAAO,CAC/B,CAMD,MAAM,YAAYC,EAAS,CACzB,QAAQ,IAAI,mBAAoBA,CAAO,EACvC,MAAMD,EAAU,CACd,OAAQ,CACN,KAAM,OACN,QAAuCC,CACxC,CACP,EAEI,OAAO,KAAK,WAAWD,CAAO,CAC/B,CAMD,MAAM,WAAWE,EAAe,CAC9B,GAAI,CAEE,KAAK,kBACP,KAAK,gBAAgB,QACrB,MAAM,IAAI,QAASC,GAAY,WAAWA,EAAS,GAAG,CAAC,GAGzD,KAAK,gBAAkB,IAAI,gBAC3B,KAAM,CAAE,OAAAC,CAAM,EAAK,KAAK,gBAGxB,KAAK,SAAS,KAAK,SAAU,CAAE,SAAU,EAAI,CAAE,EAE/C,MAAMC,EAAW,MAAM,MAAM,KAAK,SAAU,CAC1C,OAAQ,OACR,QAAS,CACP,eAAgB,mBAChB,OAAQ,mBACT,EACD,KAAM,KAAK,UAAU,CACnB,OAAQ,KAAK,OACb,OAAQH,EAAc,MAChC,CAAS,EACD,YAAa,UACb,OAAAE,CACR,CAAO,EAED,GAAI,CAACC,EAAS,GACZ,MAAM,IAAI,MAAM,6BAA6BA,EAAS,MAAM,EAAE,EAGhE,MAAM,KAAK,kBAAkBA,CAAQ,CACtC,OAAQC,EAAO,CACd,GAAIA,EAAM,OAAS,aAAc,CAC/B,QAAQ,MAAM,0CAA0C,EACxD,MACD,CACD,KAAK,YAAYA,CAAK,CACvB,CACF,CAED,iCAAkC,CAChC,KAAK,SAAS,GAAG,4BAA8BN,GAAY,CAEzD,MAAMO,EAAcP,EAAQ,OAAS,iBACrC,KAAK,SAAS,KAAK,cAAeO,CAAW,EAC7C,KAAK,+BAA+BP,EAASO,CAAW,CAC9D,CAAK,CACF,CAED,MAAM,+BAA+BP,EAASO,EAAa,CACzD,GAAIP,EAAQ,MAAQA,EAAQ,KAAK,WAAW,OAAO,EAAG,CACpD,MAAME,EAAgB,CACpB,OAAQ,CACN,KAAMF,EAAQ,KACd,QAAS,CACP,MAAOO,CACR,CACF,CACT,EACM,OAAO,KAAK,WAAWL,CAAa,CAC1C,SAAeF,EAAQ,OAAS,SAAU,CACpC,MAAME,EAAgB,CACpB,OAAQ,CACN,KAAM,SACN,QAAS,CACP,OAAQF,EAAQ,QAAQ,OACxB,MAAOA,EAAQ,QAAQ,OAAS,GAChC,SAAUA,EAAQ,QAAQ,UAAY,CAAE,CACzC,CACF,CACT,EACM,OAAO,KAAK,WAAWE,CAAa,CAC1C,SAAeF,EAAQ,OAAS,SAAU,CACpC,MAAMQ,EAAiB,CACrB,OAAQ,CACN,KAAM,SACN,QAAS,UACV,CACT,EACM,KAAK,KAAK,WAAWA,CAAc,CACzC,KAAW,IAAIR,EAAQ,OAEjB,OAAO,KAAK,WAAW,CAAE,OAAQA,EAAQ,MAAM,CAAE,EAC5C,CAEL,MAAMQ,EAAiB,CACrB,QAAS,CACP,KAAM,OACN,QAASD,CACV,CACT,EACM,KAAK,KAAK,WAAWC,CAAc,CACpC,EACF,CAOD,MAAM,kBAAkBH,EAAU,CAChC,MAAMI,EAASJ,EAAS,KAAK,UAAS,EAChCK,EAAU,IAAI,YAAY,OAAO,EACvC,IAAIC,EAAS,GAEb,GAAI,CACF,OAAa,CACX,KAAM,CAAE,KAAAC,EAAM,MAAAC,CAAK,EAAK,MAAMJ,EAAO,KAAI,EACzC,GAAIG,EAAM,CACR,KAAK,SAAS,KAAK,MAAO,CAAE,CAAA,EAC5B,KACD,CAEDD,GAAUD,EAAQ,OAAOG,EAAO,CAAE,OAAQ,EAAI,CAAE,EAChD,MAAMC,EAASH,EAAO,MAAM;AAAA;AAAA,CAAM,EAClCA,EAASG,EAAO,MAEhBA,EAAO,QAASC,GAAa,CACvBA,EAAS,SAAW,IACxB,KAAK,mBAAmBA,CAAQ,CAC1C,CAAS,CACF,CACF,OAAQT,EAAO,CACd,KAAK,YAAYA,CAAK,CAC5B,QAAc,CACR,KAAK,SAAS,KAAK,SAAU,CAAE,SAAU,EAAK,CAAE,CACjD,CACF,CAOD,mBAAmBS,EAAU,CAC3B,GAAI,CACF,MAAMC,EAAQD,EAAS,MAAM;AAAA,CAAI,EAC3BE,EAAgBD,EAAM,KAAME,GAASA,EAAK,WAAW,QAAQ,CAAC,EAC9DC,EAAWH,EAAM,KAAME,GAASA,EAAK,WAAW,OAAO,CAAC,EAC9D,QAAQ,IAAI,iBAAkBD,CAAa,EAE3C,MAAMG,EAAYH,EACdA,EAAc,MAAM,GAAG,EAAE,CAAC,EAAE,KAAM,EAClC,QACEI,EAAOF,EACT,KAAK,MAAMJ,EAAS,UAAUA,EAAS,QAAQ,OAAO,EAAI,CAAC,EAAE,MAAM,EACnE,KAEJ,OAAQK,EAAS,CACf,IAAK,QACH,KAAK,aAAaC,CAAI,EACtB,QAAQ,IAAI,eAAgBA,CAAI,EAChC,MACF,IAAK,aACH,KAAK,iBAAiBA,CAAI,EAC1B,QAAQ,IAAI,4BAA6BA,CAAI,EAC7C,KACH,CACF,OAAQf,EAAO,CACd,KAAK,YAAYA,CAAK,CACvB,CACF,CAOD,aAAagB,EAAO,CAClB,GAAI,CAACA,EAAM,KAAM,CACf,QAAQ,KAAK,+BAAgCA,CAAK,EAClD,MACD,CAID,OAFA,QAAQ,IAAI,4BAA6BA,CAAK,EAEtCA,EAAM,KAAI,CAChB,IAAK,OACH,KAAK,SAAS,KAAK,8BAA+B,CAChD,QAASA,EAAM,QAAQ,QACvB,SAAUA,EAAM,QAAQ,QAClC,CAAS,EACD,MACF,IAAK,SACH,KAAK,SAAS,KAAK,kBAAmB,CACpC,QAASA,EAAM,QAAQ,OACjC,CAAS,EACD,MACF,IAAK,WACH,KAAK,SAAS,KAAK,oBAAqB,CACtC,KAAM,WACN,MAAOA,EAAM,QAAQ,KAC/B,CAAS,EACD,MACF,IAAK,gBACC,KAAK,OAAS,WAChB,KAAK,SAAS,KAAK,eAAgBA,EAAM,OAAO,EAElD,MACF,QACE,QAAQ,KAAK,yBAAyBA,EAAM,IAAI,GAAIA,CAAK,CAC5D,CACF,CAOD,iBAAiBtB,EAAS,CACxB,GAAI,CAACA,GAAW,CAACA,EAAQ,MAAO,CAC9B,QAAQ,KAAK,8BAA+BA,CAAO,EACnD,MACD,CAED,OAAQA,EAAQ,MAAK,CACnB,IAAK,QACH,KAAK,kBAAoB,GAEzB,MAEF,IAAK,UACCA,EAAQ,UAEV,KAAK,mBAAqBA,EAAQ,QAElC,KAAK,gBAAgB,WAAWA,EAAQ,OAAO,EAC/C,QAAQ,IAAI,0BAA2BA,EAAQ,OAAO,GAExD,MAEF,IAAK,MAEH,KAAK,gBAAgB,MAErB,MAAMuB,EAAYC,EAAc,KAAK,iBAAiB,EACtD,KAAK,SAAS,KAAK,eAAgB,CACjC,QAASD,EACT,WAAY,EACtB,CAAS,EAED,KAAK,SAAS,KAAK,4BAA6B,CAC9C,QAASA,EACT,SAAU,IACpB,CAAS,EACD,KAAK,kBAAoB,KACzB,MAEF,QACE,QAAQ,KAAK,4BAA6BvB,EAAQ,KAAK,CAC1D,CACF,CAQD,oBAAoBC,EAASwB,EAAU,CACrC,KAAK,SAAS,KAAK,kBAAmB,CACpC,QAASxB,EACT,SAAAwB,EACA,WAAY,EAClB,CAAK,CACF,CAOD,YAAYnB,EAAO,CACjB,QAAQ,MAAM,iBAAkBA,CAAK,EACrC,KAAK,SAAS,KAAK,QAAS,CAAE,QAASA,EAAM,OAAO,CAAE,EACtD,KAAK,SAAS,KAAK,SAAU,CAAE,SAAU,EAAK,CAAE,CACjD,CAMD,SAAU,CACJ,KAAK,iBACP,KAAK,gBAAgB,QAEvB,KAAK,SAAS,oBACf,CACH"}