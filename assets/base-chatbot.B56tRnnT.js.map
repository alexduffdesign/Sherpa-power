{"version":3,"file":"base-chatbot.B56tRnnT.js","sources":["../frontend/baseChatbot/base-chatbot.js"],"sourcesContent":["// /assets/scripts/chatbot/core/base-chatbot.js\n\nimport EventEmitter from \"eventemitter3\";\n\n/**\n * ChatbotCore Class\n * Handles communication with Voiceflow API via Gadget middleware and processes responses\n */\nclass ChatbotCore {\n  /**\n   * @param {Object} config - Configuration object\n   * @param {string} config.type - Type of chatbot ('main' or 'section')\n   * @param {string} config.endpoint - API endpoint URL\n   * @param {string} config.userID - Unique user identifier\n   */\n  constructor(config) {\n    if (!config.userID) {\n      throw new Error(\"ChatbotCore requires a userID\");\n    }\n    if (!config.endpoint) {\n      throw new Error(\"ChatbotCore requires an endpoint URL\");\n    }\n    if (!config.type) {\n      throw new Error(\"ChatbotCore requires a type ('main' or 'section')\");\n    }\n\n    this.userID = config.userID;\n    this.endpoint = config.endpoint;\n    this.type = config.type;\n    this.eventBus = new EventEmitter();\n    this.abortController = null;\n    this.currentCompletion = null; // For handling completion events\n  }\n\n  /**\n   * Sends a launch request to initiate the conversation\n   * @param {Object} interactPayload - Optional payload for launch\n   */\n  async sendLaunch(interactPayload = {}) {\n    console.log(\"Constructing launch payload:\", interactPayload);\n    const payload = interactPayload.action\n      ? interactPayload\n      : {\n          action: {\n            type: \"launch\",\n          },\n        };\n\n    return this.sendAction(payload);\n  }\n\n  /**\n   * Sends a user message to the chatbot\n   * @param {string | Object} message - The user's message or button payload\n   */\n  async sendMessage(message) {\n    console.log(\"Message payload:\", message);\n    const payload = {\n      action: {\n        type: \"text\",\n        payload: typeof message === \"object\" ? message : message,\n      },\n    };\n\n    return this.sendAction(payload);\n  }\n\n  /**\n   * Sends an action to the Voiceflow API via Gadget\n   * @param {Object} actionPayload - The action payload to send\n   */\n  async sendAction(actionPayload) {\n    try {\n      // Only abort if there's an existing connection\n      if (this.abortController) {\n        this.abortController.abort();\n        await new Promise((resolve) => setTimeout(resolve, 100));\n      }\n\n      this.abortController = new AbortController();\n      const { signal } = this.abortController;\n\n      // Show typing indicator\n      this.eventBus.emit(\"typing\", { isTyping: true });\n\n      const response = await fetch(this.endpoint, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          Accept: \"text/event-stream\",\n        },\n        body: JSON.stringify({\n          userID: this.userID,\n          action: actionPayload.action,\n        }),\n        credentials: \"include\",\n        signal,\n      });\n\n      if (!response.ok) {\n        throw new Error(`API responded with status ${response.status}`);\n      }\n\n      await this.handleSSEResponse(response);\n    } catch (error) {\n      if (error.name === \"AbortError\") {\n        console.debug(\"Request aborted, new request in progress\");\n        return;\n      }\n      this.handleError(error);\n    }\n  }\n\n  /**\n   * Handles the SSE response from the API\n   * @private\n   * @param {Response} response - Fetch API response object\n   */\n  async handleSSEResponse(response) {\n    const reader = response.body.getReader();\n    const decoder = new TextDecoder(\"utf-8\");\n    let buffer = \"\";\n\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          this.eventBus.emit(\"end\", {});\n          break;\n        }\n\n        buffer += decoder.decode(value, { stream: true });\n        const events = buffer.split(\"\\n\\n\");\n        buffer = events.pop();\n\n        events.forEach((eventStr) => {\n          if (eventStr.trim() === \"\") return;\n          this.processEventString(eventStr);\n        });\n      }\n    } catch (error) {\n      this.handleError(error);\n    } finally {\n      this.eventBus.emit(\"typing\", { isTyping: false });\n    }\n  }\n\n  /**\n   * Process an individual SSE event string\n   * @private\n   * @param {string} eventStr - The event string to process\n   */\n  processEventString(eventStr) {\n    try {\n      const lines = eventStr.split(\"\\n\");\n      const eventTypeLine = lines.find((line) => line.startsWith(\"event:\"));\n      const dataLine = lines.find((line) => line.startsWith(\"data:\"));\n\n      const eventType = eventTypeLine\n        ? eventTypeLine.split(\":\")[1].trim()\n        : \"trace\";\n      const data = dataLine\n        ? JSON.parse(eventStr.substring(eventStr.indexOf(\"data:\") + 5).trim())\n        : null;\n\n      if (eventType === \"trace\") {\n        this.processTrace(data);\n      }\n    } catch (error) {\n      console.error(\"Error processing SSE event:\", error);\n    }\n  }\n\n  /**\n   * Process a trace event from Voiceflow\n   * @protected\n   * @param {Object} trace - The trace object to process\n   */\n  processTrace(trace) {\n    if (!trace.type) {\n      console.warn(\"Trace without type received:\", trace);\n      return;\n    }\n\n    console.log(\"processTrace called with:\", trace);\n\n    switch (trace.type) {\n      case \"text\":\n        this.emitMessageReceived(trace.payload.message, trace.payload.metadata);\n        break;\n\n      case \"completion\":\n        this.handleCompletion(trace.payload);\n        break;\n\n      case \"choice\":\n        this.eventBus.emit(\"choicePresented\", {\n          type: \"choice\",\n          buttons: trace.payload.buttons,\n        });\n        break;\n\n      case \"carousel\":\n        this.eventBus.emit(\"carouselPresented\", {\n          type: \"carousel\",\n          items: trace.payload.cards,\n        });\n        break;\n\n      case \"device_answer\":\n        if (this.type === \"section\") {\n          this.eventBus.emit(\"deviceAnswer\", trace.payload);\n        }\n        break;\n\n      default:\n        console.warn(`Unhandled trace type: ${trace.type}`, trace);\n    }\n  }\n\n  /**\n   * Handle completion trace events for streaming\n   * @private\n   * @param {Object} payload - The payload from completion trace\n   */\n  handleCompletion(payload) {\n    if (!payload || !payload.state) {\n      console.warn(\"Invalid completion payload:\", payload);\n      return;\n    }\n\n    switch (payload.state) {\n      case \"start\":\n        this.currentCompletion = \"\";\n        break;\n\n      case \"content\":\n        if (payload.content) {\n          this.currentCompletion += payload.content;\n          this.eventBus.emit(\"partialMessage\", {\n            content: payload.content,\n            isStreamed: true, // Indicate that this is a streamed message\n          });\n        }\n        break;\n\n      case \"end\":\n        this.eventBus.emit(\"finalMessage\", {\n          content: this.currentCompletion,\n          isStreamed: true, // Indicate that this is a streamed message\n        });\n        this.currentCompletion = null;\n        break;\n\n      default:\n        console.warn(\"Unknown completion state:\", payload.state);\n    }\n  }\n\n  /**\n   * Emit a complete message received\n   * @private\n   * @param {string} message - The message content\n   * @param {Object} metadata - Optional metadata\n   */\n  emitMessageReceived(message, metadata) {\n    this.eventBus.emit(\"messageReceived\", {\n      content: message,\n      metadata,\n      isStreamed: false,\n    });\n  }\n\n  /**\n   * Handle errors in the chatbot\n   * @private\n   * @param {Error} error - The error to handle\n   */\n  handleError(error) {\n    console.error(\"Chatbot error:\", error);\n    this.eventBus.emit(\"error\", { message: error.message });\n    this.eventBus.emit(\"typing\", { isTyping: false });\n  }\n\n  /**\n   * Clean up resources\n   * @public\n   */\n  destroy() {\n    if (this.abortController) {\n      this.abortController.abort();\n    }\n    this.eventBus.removeAllListeners();\n  }\n}\n\nexport default ChatbotCore;\n"],"names":["ChatbotCore","config","EventEmitter","interactPayload","payload","message","actionPayload","resolve","signal","response","error","reader","decoder","buffer","done","value","events","eventStr","lines","eventTypeLine","line","dataLine","eventType","data","trace","metadata"],"mappings":"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"}